// SPDX-License-Identifier: GPL-2.0

//! Trait for defining `seq_file`s.
//!
//! This module allows Rust devices to implement [`struct seq_operations`] and
//! and create a file under `/proc` based on that implementation.
//!
//! C header: [`include/linux/seq_file.h`](../../../include/linux/seq_file.h)
//!
//! Reference: <https://www.kernel.org/doc/html/latest/filesystems/seq_file.html>

// Currently this module is only usable through debugfs.
#![cfg(CONFIG_DEBUG_FS)]

use core::{
    fmt::{self, Display},
    marker::PhantomData,
    ptr,
};

use crate::{
    bindings, c_str, c_types,
    debugfs::DebugFsDirEntry,
    str::{CStr, CString},
    types::PointerWrapper,
    Result,
};

/// Rust equivalent of the [`seq_operations`] interface on the C side.
///
/// # Example
///
/// ```rust,no_run
/// use kernel::prelude::*;
/// use kernel::{
///     seq_file,
///     sync::{Mutex, Ref, RefBorrow},
/// };
///
/// use kernel::{Error, Result, seq_file};
/// struct SharedStateInner {
///     token_count: usize,
/// }
///
/// struct SharedState {
///     inner: Mutex<SharedStateInner>,
/// }
///
/// struct Token
///
/// impl seq_file::SeqOperations for Token {
///     type OpenData = Ref<SharedState>;
///     type DataWrapper = Ref<SharedState>;
///     type IteratorWrapper = Box<(usize, usize)>;
///     type Item = usize;
///
///     fn open<'a>(open_data: RefBorrow<'a, SharedState>) -> Result<Ref<SharedState>> {
///         Ok(open_data.into())
///     }
///
///     fn start<'a>(data: RefBorrow<'a, SharedState>) -> Option<Self::IteratorWrapper> {
///         let total = data.inner.lock().token_count;
///         Box::try_new((total, 1)).ok()
///     }
///
///     fn next(iterator: &mut Self::IteratorWrapper) -> bool {
///         let total = iterator.0;
///         let current = iterator.1;
///         if total == current {
///             false
///         } else {
///             iterator.1 += 1;
///             true
///         }
///     }
///
///     fn current(iterator: &Self::IteratorWrapper) -> core::option::Option<Log> {
///         let total = iterator.0;
///         let current = iterator.1;
///         if total >= current {
///             Some(current)
///         } else {
///             None
///         }
///     }
/// }
/// ```
///
/// [`seq_operations`]: ../../../include/linux/seq_file.h
pub trait SeqOperations {
    /// Data stored in the seq_file's inode and accesible each time it is opened
    /// in [`SeqOperations::open`].
    type OpenData: PointerWrapper + Sync;

    /// Data stored in an opened seq_file.
    type DataWrapper: PointerWrapper;

    /// Data stored in a seq_file as it is being iterated through.
    type IteratorWrapper: PointerWrapper;

    /// Type produced on iteration.
    type Item: Display;

    /// Called when the seq_file is opened.
    fn open<'a>(
        open_data: <Self::OpenData as PointerWrapper>::Borrowed<'a>,
    ) -> Result<Self::DataWrapper>;

    /// Called once on each execution of fops->read or fops->read_iter.
    fn start<'a>(
        data: <Self::DataWrapper as PointerWrapper>::Borrowed<'a>,
    ) -> Option<Self::IteratorWrapper>;

    /// Moves the iterator to the next item. Iteration will stop if this returns
    /// `false`.
    fn next(iterator: &mut Self::IteratorWrapper) -> bool;

    /// Returns the current item. Items can be skipped by returning `None`.
    fn current<'a>(
        iterator: <Self::IteratorWrapper as PointerWrapper>::Borrowed<'a>,
    ) -> Option<Self::Item>;
}

extern "C" fn stop_callback<T: SeqOperations>(
    _m: *mut bindings::seq_file,
    v: *mut c_types::c_void,
) {
    if !v.is_null() {
        // SAFETY: `v` was created by a previous call to `next_callback` or
        // `start_callback` and both functions return either a null pointer
        // or pointer generated by `T::IteratorWrapper::into_pointer`.
        drop(unsafe { T::IteratorWrapper::from_pointer(v) })
    }
}

extern "C" fn next_callback<T: SeqOperations>(
    _m: *mut bindings::seq_file,
    v: *mut c_types::c_void,
    pos: *mut bindings::loff_t,
) -> *mut c_types::c_void {
    if v.is_null() {
        return ptr::null_mut();
    }

    // SAFETY: `v` was created by a previous call to `next_callback` or
    // `start_callback` and both functions return either a null pointer
    // or pointer generated by `T::IteratorWrapper::into_pointer`.
    // We already checked for he null pointer case above.
    let mut iterator = unsafe { T::IteratorWrapper::from_pointer(v) };

    // SAFETY: The caller guarantees tha `pos` is a valid pointer to an
    // `loff_t` and expects this function to mutate the value.
    unsafe {
        *pos += 1;
    }

    if !T::next(&mut iterator) {
        ptr::null_mut()
    } else {
        T::IteratorWrapper::into_pointer(iterator) as *mut _
    }
}

extern "C" fn show_callback<T: SeqOperations>(
    m: *mut bindings::seq_file,
    v: *mut c_types::c_void,
) -> c_types::c_int {
    const FORMAT: &CStr = c_str!("%pA");
    if v.is_null() {
        return 0;
    }
    // SAFETY: `v` was created by a previous call to `next_callback` or
    // `start_callback` and both functions return either a null pointer or
    // pointer generated by `T::IteratorWrapper::into_pointer`. We checked for
    // null pointers above.
    let iterator = unsafe { T::IteratorWrapper::borrow(v) };
    if let Some(item) = T::current(iterator) {
        // SAFETY: Calling a C function. `FORMAT` is null terminated because it
        // comes from a `CStr`.
        unsafe {
            bindings::seq_printf(
                m,
                (FORMAT as *const _) as *const _,
                (&format_args!("{}", item) as *const _) as *const _,
            );
        }
    }
    0
}

extern "C" fn start_callback<T: SeqOperations>(
    m: *mut bindings::seq_file,
    pos: *mut bindings::loff_t,
) -> *mut c_types::c_void {
    // SAFETY: This function is only called on the private_data of a file that
    // was opened with [`SeqFileOperationsVTable::<T>::open_callback`]. That
    // function stores a pointer generated with T::DataWrapper::into_pointer in
    // m->private.
    let data_wrapper = unsafe { T::DataWrapper::borrow((*m).private) };
    let iterator = T::start(data_wrapper);
    // SAFETY: The caller guarantees that `pos` points to a valid `loff_t`.
    let pos = unsafe { *pos };
    match iterator {
        Some(mut wrapper) => {
            for _ in 0..pos {
                if !T::next(&mut wrapper) {
                    return ptr::null_mut();
                }
            }
            T::IteratorWrapper::into_pointer(wrapper) as *mut _
        }
        None => ptr::null_mut(),
    }
}

pub(crate) struct SeqFileOperationsVTable<T>(PhantomData<T>);

impl<'a, T, D: 'a> SeqFileOperationsVTable<T>
where
    T: SeqOperations<DataWrapper = D>,
    D: PointerWrapper,
{
    const SEQ_VTABLE: bindings::seq_operations = bindings::seq_operations {
        start: Some(start_callback::<T>),
        stop: Some(stop_callback::<T>),
        next: Some(next_callback::<T>),
        show: Some(show_callback::<T>),
    };

    /// # Safety
    ///
    /// The `inode->i_private` must have been created by `T::OpenData::into_pointer`.
    unsafe extern "C" fn open_callback(
        inode: *mut bindings::inode,
        file: *mut bindings::file,
    ) -> c_types::c_int {
        // SAFETY: Calling a C function. Caller ensures that `file` is a valid
        // file pointer and we've statically constructed the vtable.
        let result = unsafe {
            bindings::seq_open(
                file,
                &Self::SEQ_VTABLE as *const bindings::seq_operations as *mut _,
            )
        };
        if result != 0 {
            return result;
        }

        // SAFETY: Safety condition on this function requires that `i_private`
        // was created by `T::OpenData::into_pointer`.
        let open_data = unsafe { T::OpenData::borrow((*inode).i_private) };

        let data_wrapper = match T::open(open_data) {
            Ok(data) => data,
            Err(err) => return err.to_kernel_errno(),
        };

        let data_pointer = data_wrapper.into_pointer() as *mut c_types::c_void;
        // SAFETY: The caller guarantees that `file` is a valid `file` pointer
        // and `seq_open` stores a valid `seq_file` pointer in
        // `file->private_data`.
        unsafe {
            (*((*file).private_data as *mut bindings::seq_file)).private =
                data_pointer as *mut c_types::c_void
        };
        result
    }

    const VTABLE: bindings::file_operations = bindings::file_operations {
        open: Some(Self::open_callback),
        release: Some(bindings::seq_release),
        read: Some(bindings::seq_read),
        read_iter: Some(bindings::seq_read_iter),
        llseek: Some(bindings::seq_lseek),

        check_flags: None,
        compat_ioctl: None,
        copy_file_range: None,
        fallocate: None,
        fadvise: None,
        fasync: None,
        flock: None,
        flush: None,
        fsync: None,
        get_unmapped_area: None,
        iterate: None,
        iterate_shared: None,
        iopoll: None,
        lock: None,
        mmap: None,
        mmap_supported_flags: 0,
        owner: ptr::null_mut(),
        poll: None,
        remap_file_range: None,
        sendpage: None,
        setlease: None,
        show_fdinfo: None,
        splice_read: None,
        splice_write: None,
        unlocked_ioctl: None,
        write: None,
        write_iter: None,
    };
}

/// A file in [`debugfs`] which was created using a `seq_file`.
pub struct SeqFileDebugFsDirEntry<T: SeqOperations> {
    _debugfs_entry: DebugFsDirEntry<T::OpenData>,
}

/// Create a `seq_file` in [`debugfs`].
pub fn debugfs_create_file<T: SeqOperations>(
    name: fmt::Arguments<'_>,
    data: T::OpenData,
) -> Result<SeqFileDebugFsDirEntry<T>> {
    let name = CString::try_from_fmt(name)?;
    // SAFETY: The `open` field of the vtable is valid iff the opened `inode`
    // has `i_private` generated by `T::OpenData::into_pointer`. `create_file`
    // is safe to call only if the vtable is valid when used on an inode with
    // `data::into_pointer` stored in `i_private`.
    let debugfs_entry = unsafe {
        DebugFsDirEntry::create_file(&name, data, &SeqFileOperationsVTable::<T>::VTABLE)
    }?;
    Ok(SeqFileDebugFsDirEntry {
        _debugfs_entry: debugfs_entry,
    })
}
