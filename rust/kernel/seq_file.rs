// SPDX-License-Identifier: GPL-2.0

//! Trait for defining `seq_file`s.
//!
//! This module allows Rust devices to implement [`struct seq_operations`] and
//! and create a file under `/proc` based on that implementation.
//!
//! C header: [`include/linux/seq_file.h`](../../../include/linux/seq_file.h)
//!
//! Reference: <https://www.kernel.org/doc/html/latest/filesystems/seq_file.html>

// Currently this module is only usable through proc_fs.
#![cfg_attr(not(CONFIG_PROC_FS), allow(dead_code))]

use alloc::boxed::Box;
use core::{
    iter::{Iterator, Peekable},
    marker::PhantomData,
    ptr,
};

use crate::{bindings, c_types, cstr, CStr};

#[cfg(CONFIG_PROC_FS)]
pub use proc::proc_create_seq;

/// Rust equivalent of the [`seq_operations`] interface on the C side.
///
/// # Example
///
/// ```
/// struct Data(&'static [String]);
///
/// impl seq_file::SeqOperations for Data {
///     type Item = &'static String;
///     type Iterator = core::slice::Iter<'static, String>;
///
///     fn start(arg: &Data) -> Option<Box<Peekable<Self::Iterator>>> {
///         let iter = arg.0.iter();
///         Box::try_new(iter.peekable()).ok()
///     }
///
///     fn display(item: &Self::Item) -> &str {
///         &item[..]
///     }
/// }
/// ```
///
/// [`seq_operations`]: ../../../include/linux/seq_file.h
pub trait SeqOperations {
    /// Type produced on each iteration.
    type Item;

    /// Type created when the seq file is opened.
    type Iterator: Iterator<Item = Self::Item>;

    /// Called once each time the `seq_file` is opened.
    fn start(arg: &Self) -> Option<Box<Peekable<Self::Iterator>>>;

    /// How the item will be displayed to the reader.
    fn display(item: &Self::Item) -> &str;
}

extern "C" fn stop_callback<T: SeqOperations>(
    _m: *mut bindings::seq_file,
    v: *mut c_types::c_void,
) {
    if !v.is_null() {
        // SAFETY: `v` was created by a previous call to `next_callback` or
        // `start_callback` and both functions return either a null pointer
        // or pointer generated by `Box<Peekable<T::Iterator>>::into_raw`.
        drop(unsafe { Box::from_raw(v as *mut Peekable<T::Iterator>) })
    }
}

extern "C" fn next_callback<T: SeqOperations>(
    _m: *mut bindings::seq_file,
    v: *mut c_types::c_void,
    pos: *mut bindings::loff_t,
) -> *mut c_types::c_void {
    if v.is_null() {
        return ptr::null_mut();
    }

    // SAFETY: `v` was created by a previous call to `next_callback` or
    // `start_callback` and both functions return either a null pointer
    // or pointer generated by `Box<Peekable<T::Iterator>>::into_raw`.
    // We already checked for he null pointer case above.
    let mut iterator = unsafe { Box::from_raw(v as *mut Peekable<T::Iterator>) };

    // SAFETY: The caller guarantees tha `pos` is a valid pointer to an
    // `loff_t` and expects this function to mutate the value.
    unsafe {
        *pos += 1;
    }

    iterator.next();
    match iterator.peek() {
        Some(_next) => Box::into_raw(iterator) as *mut c_types::c_void,
        None => ptr::null_mut(),
    }
}

extern "C" fn show_callback<T: SeqOperations>(
    m: *mut bindings::seq_file,
    v: *mut c_types::c_void,
) -> c_types::c_int {
    const FORMAT: CStr<'static> = cstr!("%.*s");
    // SAFETY: `v` was created by a previous call to `next_callback` or
    // `start_callback` and both functions return either a null pointer
    // or pointer generated by `Box<Peekable<T::Iterator>>::into_raw`.
    if let Some(iterator) = unsafe { (v as *mut Peekable<T::Iterator>).as_mut() } {
        if let Some(item) = iterator.peek() {
            let s = T::display(item);
            // SAFETY: Calling a C function. `FORMAT` is null terminated because
            // it comes from a `CStr`. `s` does not need to be null terminated
            // because we are only printing the first `s.len()` bytes.
            unsafe {
                bindings::seq_printf(
                    m,
                    FORMAT.as_ptr() as *const c_types::c_char,
                    s.len(),
                    s.as_ptr() as *const u8 as *const c_types::c_char,
                );
            }
        }
    }
    0
}

extern "C" fn start_callback<T: SeqOperations>(
    m: *mut bindings::seq_file,
    pos: *mut bindings::loff_t,
) -> *mut c_types::c_void {
    // SAFETY: This function will be called by opening a proc file generated
    // using `proc_open_callback::<T>`, so the `private` field
    // of `m` is guaranteed to be a valid pointer to `T`.
    let arg = unsafe { &*((*m).private as *const T) };
    // SAFETY: The caller guarantees that `pos` points to a valid `loff_t`.
    let pos = unsafe { *pos };
    match T::start(arg) {
        Some(mut wrapper) => {
            for _ in 0..pos {
                wrapper.next();
            }
            match wrapper.peek() {
                Some(_next) => Box::into_raw(wrapper) as *mut c_types::c_void,
                None => ptr::null_mut(),
            }
        }
        None => ptr::null_mut(),
    }
}

struct SeqFileOperationsVTable<T>(PhantomData<T>);

impl<T: SeqOperations> SeqFileOperationsVTable<T> {
    const VTABLE: bindings::seq_operations = bindings::seq_operations {
        start: Some(start_callback::<T>),
        stop: Some(stop_callback::<T>),
        next: Some(next_callback::<T>),
        show: Some(show_callback::<T>),
    };

    const fn build() -> &'static bindings::seq_operations {
        &Self::VTABLE
    }
}

#[cfg(CONFIG_PROC_FS)]
mod proc {
    use super::*;
    use crate::{proc_fs, proc_fs::ProcDirEntry, KernelResult};

    extern "C" fn proc_open_callback<T: SeqOperations>(
        inode: *mut bindings::inode,
        file: *mut bindings::file,
    ) -> c_types::c_int {
        // SAFETY: Calling a C function.
        let result = unsafe { bindings::seq_open(file, SeqFileOperationsVTable::<T>::build()) };
        if result == 0 {
            // SAFETY: Calling a C function.
            let data = unsafe { bindings::PDE_DATA(inode) };
            // SAFETY: `file` is a valid pointer.
            let seq_file = unsafe { (*file).private_data as *mut bindings::seq_file };
            // SAFETY: `seq_open` allocates a `seq_file` in `(*file).private_data`
            // and we've checked that `seq_open` succeeded so `seq_file` is a valid
            // pointer.
            unsafe { (*seq_file).private = data };
            0
        } else {
            result
        }
    }

    struct SeqFileProcOperationsVTable<T>(PhantomData<T>);

    impl<T: SeqOperations> SeqFileProcOperationsVTable<T> {
        const VTABLE: bindings::proc_ops = bindings::proc_ops {
            proc_flags: 0,
            proc_open: Some(proc_open_callback::<T>),
            proc_read: Some(bindings::seq_read),
            proc_read_iter: Some(bindings::seq_read_iter),
            proc_write: None,
            proc_lseek: Some(bindings::seq_lseek),
            proc_release: Some(bindings::seq_release),
            proc_poll: None,
            proc_ioctl: None,
            proc_mmap: None,
            proc_get_unmapped_area: None,
        };

        const fn build() -> &'static bindings::proc_ops {
            &Self::VTABLE
        }
    }

    /// Create an entry in `/proc` for a `seq_file`.
    pub fn proc_create_seq<T: SeqOperations>(
        name: CStr<'static>,
        data: T,
    ) -> KernelResult<ProcDirEntry<T>> {
        proc_fs::proc_create_data(name, SeqFileProcOperationsVTable::<T>::build(), data)
    }
}
